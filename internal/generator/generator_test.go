package generator_test

import (
	"fmt"
	"github.com/csueiras/reinforcer/internal/generator"
	"github.com/csueiras/reinforcer/internal/loader"
	"github.com/stretchr/testify/require"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/go/packages/packagestest"
	"testing"
)

type input struct {
	interfaceName string
	code          string
}

func TestGenerator_Generate(t *testing.T) {
	tests := []struct {
		name    string
		inputs  map[string]input
		outCode *generator.Generated
		wantErr bool
	}{
		{
			name: "Interface without retryable methods",
			inputs: map[string]input{
				"service.go": {
					interfaceName: "Service",
					code: `package fake

import goctx "context"

type Service interface {
	A(ctx goctx.Context)
}
`,
				},
			},
			wantErr: true,
		},
		{
			name: "Using aliased import",
			inputs: map[string]input{
				"my_service.go": {
					interfaceName: "Service",
					code: `package fake

import goctx "context"

type Service interface {
	A(ctx goctx.Context) error
}
`,
				},
			},
			outCode: &generator.Generated{
				Common: `// Code generated by reinforcer, DO NOT EDIT.

package resilient

import (
	"context"
	goresilience "github.com/slok/goresilience"
)

type base struct {
	errorPredicate func(string, error) bool
	runnerFactory  runnerFactory
}
type runnerFactory interface {
	GetRunner(name string) goresilience.Runner
}

var RetryAllErrors = func(_ string, _ error) bool {
	return true
}

type Option func(*base)

func WithRetryableErrorPredicate(fn func(string, error) bool) Option {
	return func(o *base) {
		o.errorPredicate = fn
	}
}
func (b *base) run(ctx context.Context, name string, fn func(ctx context.Context) error) error {
	return b.runnerFactory.GetRunner(name).Run(ctx, fn)
}
`,
				Files: map[string]*generator.GeneratedFile{
					"my_service.go": {
						TypeName: "GeneratedService",
						Contents: `// Code generated by reinforcer, DO NOT EDIT.

package resilient

import "context"

type targetService interface {
	A(ctx context.Context) error
}
type GeneratedService struct {
	*base
	delegate targetService
}

func NewService(delegate targetService, runnerFactory runnerFactory) *GeneratedService {
	if delegate == nil {
		panic("provided nil delegate")
	}
	if runnerFactory == nil {
		panic("provided nil runner factory")
	}
	return &GeneratedService{
		base: &base{
			errorPredicate: RetryAllErrors,
			runnerFactory:  runnerFactory,
		},
		delegate: delegate,
	}
}
func (g *GeneratedService) A(ctx context.Context) error {
	var nonRetryableErr error
	err := g.run(ctx, "A", func(ctx context.Context) error {
		var err error
		err = g.delegate.A(ctx)
		if g.errorPredicate("A", err) {
			return err
		}
		nonRetryableErr = err
		return nil
	})
	if nonRetryableErr != nil {
		return nonRetryableErr
	}
	return err
}
`,
					},
				},
			},
		},
		{
			name: "Complex",
			inputs: map[string]input{
				"users_service.go": {
					interfaceName: "Service",
					code: `package fake

import "context"

type User struct {
	Name string
}

type Service interface {
	A()
	B(ctx context.Context)
	C(ctx context.Context, param1 int, param2 *int32, param3 *User)
	GetUserID(ctx context.Context, userID string) (string, error)
	GetUserID2(ctx context.Context, userID *string) (*User, error)
}`,
				},
			},
			outCode: &generator.Generated{
				Common: `// Code generated by reinforcer, DO NOT EDIT.

package resilient

import (
	"context"
	goresilience "github.com/slok/goresilience"
)

type base struct {
	errorPredicate func(string, error) bool
	runnerFactory  runnerFactory
}
type runnerFactory interface {
	GetRunner(name string) goresilience.Runner
}

var RetryAllErrors = func(_ string, _ error) bool {
	return true
}

type Option func(*base)

func WithRetryableErrorPredicate(fn func(string, error) bool) Option {
	return func(o *base) {
		o.errorPredicate = fn
	}
}
func (b *base) run(ctx context.Context, name string, fn func(ctx context.Context) error) error {
	return b.runnerFactory.GetRunner(name).Run(ctx, fn)
}
`,
				Files: map[string]*generator.GeneratedFile{
					"users_service.go": {
						TypeName: "GeneratedService",
						Contents: `// Code generated by reinforcer, DO NOT EDIT.

package resilient

import (
	"context"
	unresilient "github.com/csueiras/fake/unresilient"
)

type targetService interface {
	A()
	B(ctx context.Context)
	C(ctx context.Context, arg1 int, arg2 *int32, arg3 *unresilient.User)
	GetUserID(ctx context.Context, arg1 string) (string, error)
	GetUserID2(ctx context.Context, arg1 *string) (*unresilient.User, error)
}
type GeneratedService struct {
	*base
	delegate targetService
}

func NewService(delegate targetService, runnerFactory runnerFactory) *GeneratedService {
	if delegate == nil {
		panic("provided nil delegate")
	}
	if runnerFactory == nil {
		panic("provided nil runner factory")
	}
	return &GeneratedService{
		base: &base{
			errorPredicate: RetryAllErrors,
			runnerFactory:  runnerFactory,
		},
		delegate: delegate,
	}
}
func (g *GeneratedService) A() {
	g.delegate.A()
}
func (g *GeneratedService) B(ctx context.Context) {
	g.delegate.B(ctx)
}
func (g *GeneratedService) C(ctx context.Context, arg1 int, arg2 *int32, arg3 *unresilient.User) {
	g.delegate.C(ctx, arg1, arg2, arg3)
}
func (g *GeneratedService) GetUserID(ctx context.Context, arg1 string) (string, error) {
	var nonRetryableErr error
	var r0 string
	err := g.run(ctx, "GetUserID", func(ctx context.Context) error {
		var err error
		r0, err = g.delegate.GetUserID(ctx, arg1)
		if g.errorPredicate("GetUserID", err) {
			return r0, err
		}
		nonRetryableErr = err
		return nil
	})
	if nonRetryableErr != nil {
		return r0, nonRetryableErr
	}
	return r0, err
}
func (g *GeneratedService) GetUserID2(ctx context.Context, arg1 *string) (*unresilient.User, error) {
	var nonRetryableErr error
	var r0 *unresilient.User
	err := g.run(ctx, "GetUserID2", func(ctx context.Context) error {
		var err error
		r0, err = g.delegate.GetUserID2(ctx, arg1)
		if g.errorPredicate("GetUserID2", err) {
			return r0, err
		}
		nonRetryableErr = err
		return nil
	})
	if nonRetryableErr != nil {
		return r0, nonRetryableErr
	}
	return r0, err
}
`,
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := generator.NewGenerator()

			ifaces := loadInterface(t, tt.inputs)
			got, err := g.Generate(generator.Config{
				OutPkg: "resilient",
				Files:  ifaces,
			})

			if tt.wantErr {
				require.Error(t, err)
			} else {
				require.NotNil(t, got)
				require.NoError(t, err)

				var expected []string
				for fileName := range tt.outCode.Files {
					expected = append(expected, fileName)
				}
				var files []string
				for fileName := range got.Files {
					files = append(files, fileName)
				}
				require.ElementsMatch(t, expected, files)

				for fileName, genFile := range got.Files {
					require.Equal(t, tt.outCode.Files[fileName].TypeName, genFile.TypeName, "File %s type names don't match", fileName)
					require.Equal(t, tt.outCode.Files[fileName].Contents, genFile.Contents, "File %s contents doesn't match", fileName)
				}
				require.Equal(t, tt.outCode, got)
			}
		})
	}
}

func loadInterface(t *testing.T, filesCode map[string]input) map[string]*generator.FileConfig {
	pkg := "github.com/csueiras/fake/unresilient"
	var interfaces []string

	m := map[string]interface{}{}
	for fileName, in := range filesCode {
		m[fileName] = in.code
		interfaces = append(interfaces, in.interfaceName)
	}

	mods := []packagestest.Module{
		{
			Name:  pkg,
			Files: m,
		},
	}
	exported := packagestest.Export(t, packagestest.GOPATH, mods)
	t.Cleanup(exported.Cleanup)

	l := loader.NewLoader(func(cfg *packages.Config, patterns ...string) ([]*packages.Package, error) {
		exported.Config.Mode = cfg.Mode
		return packages.Load(exported.Config, patterns...)
	})

	loadedTypes := make(map[string]*generator.FileConfig)
	for fileName, in := range filesCode {
		_, svc, err := l.Load(pkg, in.interfaceName)
		require.NoError(t, err)
		loadedTypes[fileName] = &generator.FileConfig{
			SrcTypeName:   in.interfaceName,
			OutTypeName:   fmt.Sprintf("Generated%s", in.interfaceName),
			InterfaceType: svc,
		}
	}
	return loadedTypes
}
