package generator

import (
	"bytes"
	"fmt"
	"github.com/csueiras/reinforcer/internal/generator/method"
	"github.com/csueiras/reinforcer/internal/generator/passthrough"
	"github.com/csueiras/reinforcer/internal/generator/retryable"
	. "github.com/dave/jennifer/jen"
	"go/types"
	"strings"
)

var NoRetryableMethodsErr = fmt.Errorf("no methods returning errors were found in the target")
var fileHeader = "Code generated by reinforcer, DO NOT EDIT."

type FileConfig struct {
	SrcTypeName   string
	OutTypeName   string
	InterfaceType *types.Interface
}

func (f *FileConfig) targetName() string {
	return "target" + f.SrcTypeName
}

func (f *FileConfig) receiverName() string {
	return strings.ToLower(f.OutTypeName[0:1])
}

type Config struct {
	OutPkg string
	Files  map[string]*FileConfig
}

type GeneratedFile struct {
	TypeName string
	Contents string
}

type Generated struct {
	Common string
	Files  map[string]*GeneratedFile
}

type generator struct {
}

func NewGenerator() *generator {
	return &generator{}
}

func (g *generator) Generate(cfg Config) (*Generated, error) {
	if len(cfg.Files) == 0 {
		return nil, fmt.Errorf("must provide at least one file for generation")
	}

	c, err := g.generateCommon(cfg.OutPkg)
	if err != nil {
		return nil, err
	}

	gen := &Generated{
		Common: c,
		Files:  make(map[string]*GeneratedFile),
	}

	for fileName, fileConfig := range cfg.Files {
		s, err := g.generateFile(cfg.OutPkg, fileConfig)
		if err != nil {
			return nil, err
		}
		gen.Files[fileName] = &GeneratedFile{
			TypeName: fileConfig.OutTypeName,
			Contents: s,
		}
	}

	return gen, nil
}

// generateFile generates the proxy code for the given interface, the interface must have at least one method returning an
// error as those are the only ones wrapped in the middleware
func (g *generator) generateFile(outPkg string, fileCfg *FileConfig) (string, error) {
	if fileCfg == nil {
		return "", fmt.Errorf("nil config")
	}

	methods, err := g.parseMethods(fileCfg.InterfaceType)
	if err != nil {
		return "", err
	}

	f := NewFile(outPkg)
	f.HeaderComment(fileHeader)

	// Declare the target interface we are proxying
	var declMethods []Code
	for _, meth := range methods {
		declMethods = append(declMethods, Id(meth.Name).Params(meth.ParametersNameAndType...).Params(meth.ReturnTypes...))
	}
	f.Add(Type().Id(fileCfg.targetName()).Interface(
		declMethods...,
	))

	// Declare the proxy implementation
	f.Add(Type().Id(fileCfg.OutTypeName).Struct(
		Op("*").Id("base"),
		Id("delegate").Id(fileCfg.targetName()),
	))

	// Declare the ctor
	f.Add(Func().Id("New"+fileCfg.SrcTypeName).Params(
		Id("delegate").Id(fileCfg.targetName()),
		Id("runnerFactory").Id("runnerFactory"),
	).Op("*").Id(fileCfg.OutTypeName).Block(
		// if delegate == nil
		If(Id("delegate").Op("==").Nil().Block(
			// panic("...")
			Panic(Lit("provided nil delegate")),
		)),
		// if runnerFactory == nil
		If(Id("runnerFactory").Op("==").Nil().Block(
			// panic("...")
			Panic(Lit("provided nil runner factory")),
		)),
		Return(Op("&").Id(fileCfg.OutTypeName).Values(Dict{
			// embed the base struct
			Id("base"): Op("&").Id("base").Values(Dict{
				Id("errorPredicate"): Id("RetryAllErrors"),
				Id("runnerFactory"):  Id("runnerFactory"),
			}),
			Id("delegate"): Id("delegate"),
		})),
	))

	// Declare all of our proxy methods
	for _, mm := range methods {
		if mm.ReturnsError {
			r := retryable.NewRetryable(mm, fileCfg.OutTypeName, fileCfg.receiverName())
			s, err := r.Statement()
			if err != nil {
				return "", err
			}
			f.Add(s)
		} else {
			p := passthrough.NewPassThrough(mm, fileCfg.OutTypeName, fileCfg.receiverName())
			s, err := p.Statement()
			if err != nil {
				return "", err
			}
			f.Add(s)
		}
	}
	return renderToString(f)
}

func (g *generator) generateCommon(outPkg string) (string, error) {
	f := NewFile(outPkg)
	f.HeaderComment(fileHeader)

	// Declare base impl that will be used to hold the common fields
	f.Add(Type().Id("base").Struct(
		Id("errorPredicate").Add(Func().Params(Id("string"), Id("error")).Params(Bool())),
		Id("runnerFactory").Id("runnerFactory"),
	))

	// Declares the runner's factory
	f.Add(Type().Id("runnerFactory").Interface(
		Id("GetRunner").Params(Id("name").Id("string")).Qual("github.com/slok/goresilience", "Runner"),
	))

	// Declare the RetryAllErrors predicate that enables the middleware on all errors received from proxy call
	f.Add(Var().Id("RetryAllErrors").Op("=").Func().Params(Id("_").Id("string"), Id("_").Id("error")).Params(Id("bool")).Block(
		Return(Lit(true)),
	))

	// Declare the Option type that allows to configure the service
	f.Add(Type().Id("Option").Func().Params(Op("*").Id("base")))

	// Declare the WithRetryableErrorPredicate Option which configures the predicate to determine which errors should be retried
	f.Add(Func().Id("WithRetryableErrorPredicate").Params(Id("fn").Id("func").Params(Id("string"), Id("error")).Params(Bool())).Params(Id("Option")).Block(
		Return(Func().Params(Id("o").Op("*").Id("base")).Block(
			Id("o").Dot("errorPredicate").Op("=").Id("fn"),
		)),
	))

	// Declare our runner helper
	f.Add(Func().Params(Id("b").Op("*").Id("base")).Id("run").Params(
		Id("ctx").Qual("context", "Context"),
		Id("name").Id("string"),
		Id("fn").Func().Params(Id("ctx").Qual("context", "Context")).Id("error"),
	).Id("error").Block(
		Return(Id("b").Dot("runnerFactory").Dot("GetRunner").Call(Id("name")).Dot("Run").Call(Id("ctx"), Id("fn"))),
	))
	return renderToString(f)
}

func (g *generator) parseMethods(interfaceType *types.Interface) ([]*method.Method, error) {
	anyErrorReturningMethod := false
	var methods []*method.Method
	for m := 0; m < interfaceType.NumMethods(); m++ {
		meth := interfaceType.Method(m)
		mm, err := method.ParseMethod(meth.Name(), meth.Type().(*types.Signature))
		if err != nil {
			return nil, err
		}
		if mm.ReturnsError {
			anyErrorReturningMethod = true
		}
		methods = append(methods, mm)
	}
	if !anyErrorReturningMethod {
		return nil, NoRetryableMethodsErr
	}
	return methods, nil
}

func renderToString(f *File) (string, error) {
	b := &bytes.Buffer{}
	if err := f.Render(b); err != nil {
		return "", err
	}
	return b.String(), nil
}
